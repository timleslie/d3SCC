<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>D3 Test</title>
        <script type="text/javascript" src="d3/d3.v3.js"></script>
    </head>
    <style>
    
text {
    font-family: sans-serif;
    font-size: 14px;
}

</style>
    <body>
        <script type="text/javascript">

var data = {
    index: 1,
    label: 10,
    stack: [],
    DFS: [],
    SCCs: [{x: 0, y: 0, visible: false},
	   {x: 0, y: 0, visible: false},
	   {x: 0, y: 0, visible: false},
	   {x: 0, y: 0, visible: false}],
    nodes: [{x: 500, y: 340, text: "A", fixed: true},
	    {x: 350, y: 250, text: "B", fixed: true},
	    {x: 300, y: 160, text: "C", fixed: true},
	    {x: 260, y: 250, text: "D", fixed: true},
	    {x: 500, y: 250, text: "E", fixed: true},
	    {x: 540, y: 160, text: "F", fixed: true},
	    {x: 450, y: 160, text: "G", fixed: true},
	    {x: 350, y: 60, text: "H", fixed: true},
	    {x: 450, y: 60, text: "I", fixed: true},
	    {x: 540, y: 60, text: "J", fixed: true}],
    links: [{nodes: [0, 1], bidirectional: false},
	    {nodes: [1, 2], bidirectional: false},
	    {nodes: [2, 3], bidirectional: false},
	    {nodes: [3, 1], bidirectional: false},
	    {nodes: [0, 4], bidirectional: true},
	    {nodes: [4, 5], bidirectional: false},
	    {nodes: [5, 6], bidirectional: false},
	    {nodes: [6, 4], bidirectional: false},
	    {nodes: [2, 7], bidirectional: false},
	    {nodes: [8, 9], bidirectional: true}],
    need_to_push: -1,
    need_to_find_min: -1,
    need_to_process_root: -1,
    need_to_process_non_root: -1,
    need_to_push_stack: -1,
    need_to_pop_label: -1,
    flying_index: [],
    flying_min: [],
    flying_label: [],
    };

if (!Array.prototype.last){
    Array.prototype.last = function(){
        return this[this.length - 1];
    };
};

function update_DFS_head(data, v) {
    data.nodes[v].link = data.index;
    data.index++;
    data.flying_index = [v];
}

function push_links(data, v) {
    var target;
    for (var i = 0; i < data.links.length; i++) {
	var link = data.links[i];
	if (v == link.nodes[0]) {
	    target = link.nodes[1];
	    if (data.nodes[target].link === undefined) {
		if (data.DFS.indexOf(target) >= 0) {
		    data.DFS.splice(data.DFS.indexOf(target), 1);
		}
		data.DFS.push(target);
	    }
	}
	if (v == link.nodes[1] && link.bidirectional) {
	    target = link.nodes[0];
	    if (data.nodes[target].link === undefined) {
		if (data.DFS.indexOf(target) >= 0) {
		    data.DFS.splice(data.DFS.indexOf(target), 1);
		}
		data.DFS.push(target);
	    }
	}
    }
}

function min_link(data, v) {
    var target;
    var min = data.nodes[v].link;
    for (var i = 0; i < data.links.length; i++) {
	var link = data.links[i];
	if (v == link.nodes[0]) {
	    target = link.nodes[1];
	    if (data.nodes[target].link < min) {
		min = data.nodes[target].link;
		data.flying_min = [target];
	    }
	}
	if (v == link.nodes[1] && link.bidirectional) {
	    target = link.nodes[0];
	    if (data.nodes[target].link < min) {
		min = data.nodes[target].link;
		data.flying_min = [target];
	    }
	}

    }
    return min;
}

function process_non_root(data, v) {
    data.stack.push(v);
}

function process_root(data, link) {
    // Label all nodes

    var i = data.stack.length - 1;
    while (i >= 0 && data.nodes[data.stack[i]].link >= link) {
	data.nodes[data.stack[i]].link = data.label;
	data.flying_label.push(i);
	i--;
    }
    data.SCCs[data.nodes.length - data.label].visible = true;
}

function pop_labelled(data) { 
    // Pop nodes, update index/label
    while(data.stack.length > 0 && data.nodes[data.stack.last()].link == data.label) {
	data.stack.pop();
	data.index--;
    }
    data.label--;
}

function backtrack(data, v) {
    var min = min_link(data, v);
    data.need_to_push_stack = v;
    if (min == data.nodes[v].link) {
	data.need_to_process_root = data.nodes[v].link;
	data.flying_min = [v];
    } else {
	data.nodes[v].link = min; // has a lower link, push to stack
    }
}


function process_node(data) {
    data.flying_index = [];
    data.flying_min = [];
    data.flying_label = [];
    if (data.need_to_push >= 0) {
	v = data.need_to_push;
	data.need_to_push = -1;
	// Add links
	push_links(data, v);
    } else if (data.need_to_find_min >= 0) {
	v = data.need_to_find_min;
	data.need_to_find_min = -1;
	backtrack(data, v);
    } else if (data.need_to_push_stack >= 0) {
	v = data.need_to_push_stack;
	data.need_to_push_stack = -1;
	data.stack.push(v);
    } else if (data.need_to_process_root >= 0) {
	v = data.need_to_process_root;
	data.need_to_process_root = -1;
	process_root(data, v);
	data.need_to_pop_label = v;
    } else if (data.need_to_pop_label >= 0) {
	data.need_to_pop_label = -1;
	pop_labelled(data);
    } else {
	var v = data.DFS.last();
	if (v === undefined) {
	    // Push root to DFS
	    var i;
	    for (i=0; i < data.nodes.length; i++) {
		if (data.nodes[i].link == undefined) {
		    data.DFS.push(i);
		    break;
		}
	    }
	    if (i == data.nodes.length) {
	    }
	} else if (data.nodes[v].link === undefined) {
	    // Begin DFS update
	    update_DFS_head(data, v);
	    data.need_to_push = v;
	} else {
	    // Begin DFS backtrack
	    v = data.DFS.pop();
	    data.need_to_find_min = v;
	}
    }
}

function set_stack_label(svg, stack_x0, stack_y0, stack_w, label) {

    svg.append("g").attr("id", "label").append("text")
	.text(label)
	.attr("x", stack_x0 + stack_w/2)
	.attr("y", (h + stack_y0)/2 + 5)
	.attr("text-anchor", "middle")
}

function node_text(node) { 
    if (node.link === undefined) {
	return node.text; 
    } else {
	return node.text + ": " + node.link;
    }
}

///////// GRAPH DRAWING

var colors = d3.scale.category10();

function draw_links(data, path_g) {

    // add the links and the arrows
    //var path = svg.append("svg:g").selectAll("path")
//	.data(data.links)
//	.enter().append("svg:path")
    //    .attr("class", function(d) { return "link " + d.type; })
//	.attr("class", "link")
    //	.attr("marker-end", "url(#end)");

    console.log("DATA", data);
    console.log("DATA LINKS", data.links);
    path_g.selectAll("path")
	.data(data.links)
	.enter().append("svg:path")
    //    .attr("class", function(d) { return "link " + d.type; })
	.attr("class", "link")
	.attr("stroke-width", "2px")
	.attr("stroke", "#000")
	.attr("marker-end", "url(#end)")
	.attr("d", function(d) {
	    console.log("LINK", d);
            return "M" + 
		data.nodes[d.nodes[0]].x + "," + 
		data.nodes[d.nodes[0]].y + "L" + 
		data.nodes[d.nodes[1]].x + "," + 
		data.nodes[d.nodes[1]].y;
	});

    
    //var link = line_g.selectAll("line")
//	.data(data.links);

    // Create
  //  link.enter().append("line")
//	.attr("x1", function(d) { return data.nodes[d.nodes[0]].x; })
//	.attr("y1", function(d) { return data.nodes[d.nodes[0]].y; })
//	.attr("x2", function(d) { return data.nodes[d.nodes[1]].x; })
//	.attr("y2", function(d) { return data.nodes[d.nodes[1]].y; });
}

function draw_nodes(data, circle_g) {
    var node = circle_g.selectAll("circle")
	.data(data.nodes);

    // Default circle state:
    node.enter().append("circle")
	.attr("r", 20)
	.attr("cx", function(d) { return d.x; })
	.attr("cy", function(d) { return d.y; })
        .attr("fill", "#FFF")
	.attr("stroke", colors(7));
	
    // update
    node.transition().duration(1000)
	.attr("fill", function(d, i) {
	    var idx = i;
	    if ( data.stack.indexOf(idx) >= 0) {
		return colors(0);
	    } else if (data.DFS.indexOf(idx) >= 0) {
		return colors(1);
	    } else if (data.nodes[i].link === undefined) {
		return colors(2);
	    } else if (data.nodes[i].link > data.label) {
		return colors(9);
	    } else {
		return colors(7);
	    }
	});
}

function draw_labels(data, label_g) {
    // Labels
  //  console.log("draw_labels");
    var label = label_g.selectAll("text")
	.data(data.nodes);

    // Update
    label.transition().delay(900).text( node_text );

    // Enter
    label.enter().append("text")
	.attr("text-anchor", "middle")
	.attr("x", function(d) { return d.x; } )
	.attr("y", function(d) { return d.y + 5; } )
        .text(node_text);


}

function draw_graph(data, path_g, circle_g, label_g, SCCs) {
    draw_links(data, path_g);
    draw_nodes(data, circle_g);
    draw_labels(data, label_g);
    
    for (var i=0; i < data.SCCs.length; i++) {
	if (data.SCCs[i].visible) {
	    SCCs[i]
	        .transition().duration(1000)
	        .attr("stroke-opacity", 1)
		.attr("stroke", "#000");
	}

    }
}
///////

var hot_seat = {x: 100, y: 100};

function text_y(y, stack_h) {
    return y + 0.5*stack_h + 4;
}


function box_y(i) { return stack_y0 - box_h*(i + 1); }

function draw_DFS(data, DFS_g, stack_x0) {

    // Boxes
    var stack_rect = DFS_g.selectAll("rect")
	.data(data.DFS, function(d) { return d; });

    // Boxes are created in place and fade in
    stack_rect.enter().append("rect")
	.attr("fill", "#FFF")
	.attr("stroke", "#000")
	.attr("stroke-width", 1)
	.attr("height", box_h)
	.attr("width", box_w)
	.attr("x", function(d, i) { return stack_x0; } )
	.attr("y", function(d, i) { return box_y(i) } )
        .attr("stroke", "#FFF")
        .transition().duration(1000)
        .attr("stroke", "#000");

    // On exit, they move to the hot seat
    stack_rect.exit()
	.transition().duration(1000)
        .attr("x", hot_seat.x)
        .attr("y", hot_seat.y)
  	.remove();

    // Text
    var stack_text = DFS_g.selectAll("text")
	.data(data.DFS);

    // Text slides in from the nodes
    stack_text.enter().append("text")
	.attr("text-anchor", "middle")
	.attr("x", function(d) { return data.nodes[d].x; } )
        .attr("y", function(d) { return data.nodes[d].y + 5; } )
	.transition().duration(1000)
	.attr("x", stack_x0 + box_w/2)
  	.attr("y", function(d, i) { return text_y(box_y(i), box_h); } )

    // If we have flying text coming in, delay until it has arrived
    if (data.flying_index.length > 0) 
	stack_text.transition().delay(1000).text(function(d) { return node_text(data.nodes[d]); });
    else
	stack_text.text(function(d) { return node_text(data.nodes[d]); });

    // On exit, either fade out or move to the hot seat
    stack_text.exit()
	.transition().duration(1000)
	.attr("x", hot_seat.x + 18)
	.attr("y", text_y(hot_seat.y, box_h))
	.remove();

}

function draw_stack(data, stack_data, stack_x0, id, g, stack_x0_other) {
    var N = data.nodes.length;

    var stack_y0 = h - 30;
    var stack_w = 35;
    var stack_h = stack_y0/(N + 1);

    // Boxes
    var stack_rect = g.selectAll("rect")
	.data(stack_data, function(d) { return d; });

    // Boxes slide in from the hotseat
    stack_rect.enter().append("rect")
	.attr("fill", "#FFF")
	.attr("stroke", "#000")
	.attr("stroke-width", 1)
	.attr("height", stack_h)
	.attr("width", stack_w)
        .attr("stroke", "#000")
	.attr("x", function(d) { return hot_seat.x; } )
	.attr("y", function(d) { return hot_seat.y } )
        .transition().duration(1000)
	.attr("x", function(d, i) { return stack_x0; } )
	.attr("y", function(d, i) { return box_y(i) } )


    // On exit, fade out
    stack_rect.exit()
	.transition().duration(1000)
	.attr("stroke", "#FFF").remove();

    // Text
    var stack_text = g.selectAll("text")
	.data(stack_data);

    // Text slides in from the hot seat
    stack_text.enter().append("text")
	.attr("text-anchor", "middle")
	.attr("x", hot_seat.x + 18)
	.attr("y", text_y(hot_seat.y, stack_h))
	.transition().duration(1000)
	.attr("x", stack_x0 + stack_w/2)
  	.attr("y", function(d, i) { return text_y(box_y(i), stack_h); } )

    // Update - if we're flying in data, give it time to arrive
    if (data.flying_label.length > 0) 
	stack_text.transition().delay(1000).text(function(d) { return node_text(data.nodes[d]); });
    else
	stack_text.text(function(d) { return node_text(data.nodes[d]); });

    // On exit, fade out
    stack_text.exit()
	.transition().duration(1000)
        .attr("stroke", "#FFF")
	.remove();

}

function draw_hotseat(data, hotseat_g) {

    if (data.need_to_find_min >= 0) {
	data = [data.nodes[data.need_to_find_min]];
    } else if (data.need_to_push_stack >= 0) {
	data = [data.nodes[data.need_to_push_stack]];
	console.log("push stack", data);
    } else {
	// Hotseat is empty
	console.log("empty");
	data = [];
    }
    
    var hot_rects = hotseat_g.selectAll("rect").
	data(data);

    hot_rects.enter().append("rect")
        .attr("height", box_h)
        .attr("width", box_w)
        .attr("x", hot_seat.x)
        .attr("y", hot_seat.y)
        .attr("fill", "#FFF")
        .attr("stroke", "#FFF")
        .transition().delay(1000).duration(1e-6)
        .attr("stroke", "#000")

    hot_rects.exit().remove()

    var hot_text = hotseat_g.selectAll("text").
	data(data);

    hot_text.enter().append("text")
	.attr("text-anchor", "middle")
        .attr("x", hot_seat.x + 18)
        .attr("y", text_y(hot_seat.y, box_h));

    hot_text.transition().delay(1000).duration(1e-6)
        .text( node_text );

    hot_text.exit().remove();
}

function draw_index(data, index_g) {
    var index_text = index_g.selectAll("text")
        .data([data.index]);

    index_text.enter().append("text")
        .attr("x", 20)
        .attr("y", 20);
    // Update
    index_text.text( function(d) { return "Index: " + d; } );
}

function draw_cur_label(data, cur_label_g) {
    var cur_label_text = cur_label_g.selectAll("text")
        .data([data.label]);

    cur_label_text.enter().append("text")
        .attr("x", 20)
        .attr("y", 40);
    // Update
    cur_label_text.text( function(d) { return "Label: " + d; } );
}

function draw_flying(data, flying_g) {
    if (data.flying_index.length > 0) 
	data.flying_index.push(data.flying_index[0]);
    var flying_text = flying_g.selectAll("text")
        .data(data.flying_index)

    flying_text.enter().append("text")
        .attr("x", 60)
        .attr("y", 20)
        .text( function(d) { return data.index - 1; } )
        .transition().duration(1000)
        .attr("x", function(d, i) { if (i == 0) { return data.nodes[d].x; } else { return 31; }})
        .attr("y", function(d, i) { if (i == 0) { return data.nodes[d].y; } else { return text_y(box_y(data.DFS.length - 1), box_h); } } )
        .remove()
}

function draw_flying_min(data, flying_min_g) {

    var flying_min_text = flying_min_g.selectAll("text")
        .data(data.flying_min)

    flying_min_text.enter().append("text")
        .attr("x", function(d) { return data.nodes[d].x; } )
        .attr("y", function(d) { return data.nodes[d].y; } )
        .text( function(d) { return data.nodes[d].link; } )
        .transition().duration(1000)
        .attr("x", hot_seat.x + 18 + 4)
        .attr("y", text_y(hot_seat.y, box_h))
        .remove()
}

function draw_flying_label(data, flying_label_a_g) {

    var len = data.flying_label.length;
    var flying_nodes = [];
    for (var i=0; i < data.flying_label.length; i++) {
	flying_nodes.push(data.nodes[data.stack[data.flying_label[i]]]);
    }
    
    var flying_label_a_text = flying_label_a_g.selectAll("text")
        .data(data.flying_label)

    flying_label_a_text.enter().append("text")
        .attr("x", 60)
        .attr("y", 40)
        .text(data.label)
        .transition().duration(1000)
	.attr("x", stack_x + box_w/2 + 1)
  	.attr("y", function(d, i) { return text_y(box_y(d), box_h); } )
        .remove();

    var flying_label_b_text = flying_label_b_g.selectAll("text")
        .data(flying_nodes)

    flying_label_b_text.enter().append("text")
        .attr("x", 60)
        .attr("y", 40)
        .text(data.label)
        .transition().duration(1000)
	.attr("x", function(d) { return d.x; } )
  	.attr("y", function(d) { return d.y; } )
        .remove();

}

// Image Dimensions
var w = 600;
var h = 400;
var N = data.nodes.length;
var stack_y0 = h - 30;
var box_h = stack_y0/(N + 1);
var box_w = 35;
var circle_r = 20;

// Stack locations
var DFS_x = 10;
var stack_x = 50;

// The <svg> tag
var svg = d3.select("body").append("svg")
    .attr("width", w)
    .attr("height", h);


// The main dynamic groups
var hotseat_g = svg.append("g").attr("id", "hotseat");
var stack_g = svg.append("g").attr("id", "stack");
var DFS_g = svg.append("g").attr("id", "DFS");
var index_g = svg.append("g").attr("id", "index");
var cur_label_g = svg.append("g").attr("id", "cur_label");
var flying_g = svg.append("g").attr("id", "flying");
var flying_min_g = svg.append("g").attr("id", "flying_min");
var flying_label_a_g = svg.append("g").attr("id", "flying_label_a");
var flying_label_b_g = svg.append("g").attr("id", "flying_label_b");


// build the arrow.
svg.append("svg:defs").selectAll("marker")
    .data(["end"])      // Different link/path types can be defined here
    .enter().append("svg:marker")    // This section adds in the arrows
    .attr("id", String)
        .attr("strokeWidth", 1)
	.attr("viewBox", "0 -5 10 10")
	.attr("refX", 25)
	.attr("refY", 0)
	.attr("markerWidth", 6)
	.attr("markerHeight", 6)
	.attr("orient", "auto")
	.append("svg:path")
	.attr("d", "M0,-5L10,0L0,5");


// Graph
var graph_g = svg.append("g").attr("id", "graph");
//var line_g = graph_g.append("g").attr("id", "lines");
var path_g = graph_g.append("g").attr("id", "paths");

var circle_g = graph_g.append("g").attr("id", "circles");
var label_g = graph_g.append("g").attr("id", "labels");


var SCC_g = svg.append("g").attr("id", "SCC");

var SCCs = [
    SCC_g.append("g")
	.attr("transform", "rotate(0 340 110)")
	.append("rect")
	.attr("x", 310)
	.attr("y", 20)
	.attr("width", 80)
	.attr("height", 80)
	.attr("rx", 10)
	.attr("ry", 10)
	.attr("fill-opacity", 0)
	.attr("stroke-width", 2)
	.attr("stroke-opacity", 0)
	.attr("fill", "#FFF")
	.attr("stroke", "#FFF"),
    SCC_g.append("g")
	.attr("transform", "rotate(0 100 100)")
	.append("rect")
	.attr("x", 220)
	.attr("y", 120)
	.attr("width", 170)
	.attr("height", 170)
	.attr("rx", 10)
	.attr("ry", 10)
	.attr("fill-opacity", 0)
	.attr("stroke-width", 2)
	.attr("stroke-opacity", 0)
	.attr("fill", "#FFF")
	.attr("stroke", "#FFF"),
    SCC_g.append("g")
	.attr("transform", "rotate(0 100 100)")
	.append("rect")
	.attr("x", 410)
	.attr("y", 120)
	.attr("width", 170)
	.attr("height", 260)
	.attr("rx", 10)
	.attr("ry", 10)
	.attr("fill-opacity", 0)
	.attr("stroke-width", 2)
        .attr("stroke-opacity", 0)
	.attr("fill", "#FFF")
	.attr("stroke", "#FFF"),
    SCC_g.append("g")
	.attr("transform", "rotate(0 100 100)")
	.append("rect")
	.attr("x", 410)
	.attr("y", 20)
	.attr("width", 170)
	.attr("height", 80)
	.attr("rx", 10)
	.attr("ry", 10)
	.attr("fill-opacity", 0)
	.attr("stroke-width", 2)
	.attr("stroke-opacity", 0)
	.attr("fill", "#FFF")
	.attr("stroke", "#FFF")
]

// The static content
set_stack_label(svg, DFS_x, stack_y0, box_w, "DFS");
set_stack_label(svg, stack_x, stack_y0, box_w, "stack");

draw_graph(data, path_g, circle_g, label_g, SCCs);
draw_stack(data, data.stack, stack_x, "stack", stack_g, DFS_x);
//draw_stack(data, data.DFS, DFS_x, "dfs", DFS_g, stack_x);
draw_DFS(data, DFS_g, DFS_x);
draw_hotseat(data, hotseat_g);
draw_index(data, index_g);
draw_cur_label(data, cur_label_g);
draw_flying(data, flying_g);
draw_flying_min(data, flying_min_g);
draw_flying_label(data, flying_label_a_g, flying_label_b_g);


function update_and_draw(data) {
    process_node(data);
    draw_graph(data, path_g, circle_g, label_g, SCCs);
    draw_stack(data, data.stack, stack_x, "stack", stack_g, DFS_x);
    draw_DFS(data, DFS_g, DFS_x);
    draw_hotseat(data, hotseat_g);
    draw_index(data, index_g);
    draw_cur_label(data, cur_label_g);
    draw_flying(data, flying_g);
    draw_flying_min(data, flying_min_g);
    draw_flying_label(data, flying_label_a_g, flying_label_b_g);
}

setInterval(function() {
    update_and_draw(data);
}, 1500);
        </script>
    </body>
</html>
